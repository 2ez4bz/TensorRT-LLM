"""Abstract base class for tool parsers.

Tool parsers are used to extract tool calls from model outputs and adjust
requests before they are sent to the model. This allows different models
with different tool call formats to be supported uniformly.
"""

import os
from abc import ABC, abstractmethod
from collections.abc import Callable, Sequence
from functools import cached_property
from typing import List, NamedTuple, Optional

from tensorrt_llm.logger import logger
from tensorrt_llm.serve.openai_protocol import (ChatCompletionRequest,
                                                DeltaMessage, ToolCall)


class ExtractedToolCallInformation(NamedTuple):
    """Information about tool calls extracted from model output."""

    tools_called: bool = False
    """Whether any tools were called."""

    tool_calls: Optional[List[ToolCall]] = None
    """Extracted tool calls."""

    content: Optional[str] = None
    """Any additional content."""


class ToolParser(ABC):
    """
    Abstract ToolParser class that should not be used directly.

    Subclass this to implement tool parsing for specific models or formats.
    Provides methods for:
    - Adjusting requests before generation
    - Extracting tool calls from complete output (non-streaming)
    - Extracting tool calls from partial output (streaming)
    """

    def __init__(self, tokenizer):
        """Initialize the tool parser.

        Args:
            tokenizer: The tokenizer instance to use for parsing
        """
        # State for streaming parsing
        self.prev_tool_call_arr: List[dict] = []
        self.current_tool_id: int = -1
        self.current_tool_name_sent: bool = False
        self.streamed_args_for_tool: List[str] = []

        self.model_tokenizer = tokenizer

    @cached_property
    def vocab(self) -> dict:
        """Get the tokenizer vocabulary.

        Returns:
            Dictionary mapping tokens to token IDs
        """
        # NOTE: Only PreTrainedTokenizerFast is guaranteed to have .vocab
        # whereas all tokenizers have .get_vocab()
        if hasattr(self.model_tokenizer, 'tokenizer'):
            # TensorRT-LLM wraps the tokenizer
            return self.model_tokenizer.tokenizer.get_vocab()
        return self.model_tokenizer.get_vocab()

    def adjust_request(self,
                       request: ChatCompletionRequest) -> ChatCompletionRequest:
        """
        Adjust the request parameters before processing.

        This hook allows tool parsers to modify the request (e.g., add special
        tokens, adjust stop sequences, etc.) before the model processes it.

        Args:
            request: The incoming chat completion request

        Returns:
            The potentially modified request
        """
        return request

    @abstractmethod
    def extract_tool_calls(
        self,
        model_output: str,
        request: ChatCompletionRequest,
    ) -> ExtractedToolCallInformation:
        """
        Extract tool calls from a complete model-generated string.

        Used for non-streaming responses where we have the entire model response
        available before sending to the client. This method should be stateless.

        Args:
            model_output: The complete text generated by the model
            request: The original chat completion request

        Returns:
            ExtractedToolCallInformation containing the parsed tool calls

        Raises:
            NotImplementedError: If not implemented by subclass
        """
        raise NotImplementedError(
            "ToolParser.extract_tool_calls has not been implemented!")

    @abstractmethod
    def extract_tool_calls_streaming(
        self,
        previous_text: str,
        current_text: str,
        delta_text: str,
        previous_token_ids: Sequence[int],
        current_token_ids: Sequence[int],
        delta_token_ids: Sequence[int],
        request: ChatCompletionRequest,
    ) -> Optional[DeltaMessage]:
        """
        Extract tool calls from an incomplete response for streaming.

        This is an instance method because it requires state - the current
        tokens/diffs, but also information about what has previously been
        parsed and extracted.

        Args:
            previous_text: Text from all previous chunks
            current_text: Text including current chunk (previous + delta)
            delta_text: Text from current chunk only
            previous_token_ids: Token IDs from all previous chunks
            current_token_ids: Token IDs including current chunk
            delta_token_ids: Token IDs from current chunk only
            request: The original chat completion request

        Returns:
            DeltaMessage with tool call information, or None if not ready

        Raises:
            NotImplementedError: If not implemented by subclass
        """
        raise NotImplementedError(
            "ToolParser.extract_tool_calls_streaming has not been implemented!")


class ToolParserManager:
    """
    Registry for managing tool parser implementations.

    Allows registration and retrieval of tool parsers by name, supporting
    both decorator-based and direct registration.
    """

    _parsers: dict = {}

    @classmethod
    def get_tool_call_parser(cls, name: str) -> type:
        """
        Get tool parser class by name.

        Args:
            name: The registered name of the tool parser

        Returns:
            The tool parser class

        Raises:
            KeyError: If the parser name is not registered
        """
        if name in cls._parsers:
            return cls._parsers[name]

        raise KeyError(f"Tool parser '{name}' not found in registered parsers")

    @classmethod
    def _register_module(
        cls,
        module: type,
        module_name: Optional[str] = None,
        force: bool = True,
    ) -> None:
        """
        Internal method to register a tool parser module.

        Args:
            module: The tool parser class to register
            module_name: Name(s) to register the parser under
            force: If False, raises error if name already registered

        Raises:
            TypeError: If module is not a subclass of ToolParser
            KeyError: If name already registered and force=False
        """
        if not issubclass(module, ToolParser):
            raise TypeError(
                f"module must be subclass of ToolParser, but got {type(module)}"
            )

        if module_name is None:
            module_name = module.__name__

        if isinstance(module_name, str):
            module_names = [module_name]
        else:
            module_names = module_name

        for name in module_names:
            if not force and name in cls._parsers:
                existed_module = cls._parsers[name]
                raise KeyError(
                    f"{name} is already registered at {existed_module.__module__}"
                )
            cls._parsers[name] = module
            logger.debug(f"Registered tool parser: {name}")

    @classmethod
    def register_module(
        cls,
        name: Optional[str] = None,
        force: bool = True,
        module: Optional[type] = None,
    ) -> Callable:
        """
        Register a tool parser module.

        Can be used as a decorator or called directly:

        Examples:
            As a decorator:
            >>> @ToolParserManager.register_module("my_parser")
            >>> class MyParser(ToolParser):
            >>>     pass

            Direct registration:
            >>> ToolParserManager.register_module(
            >>>     name="my_parser", module=MyParser
            >>> )

        Args:
            name: Name to register the parser under
            force: If False, raises error if name already registered
            module: The parser class (for direct registration)

        Returns:
            The registered module or decorator function

        Raises:
            TypeError: If parameters are of wrong type
        """
        if not isinstance(force, bool):
            raise TypeError(f"force must be a boolean, but got {type(force)}")

        # Validate name parameter
        if name is not None and not isinstance(name, str):
            if not (isinstance(name, list)
                    and all(isinstance(n, str) for n in name)):
                raise TypeError(
                    "name must be None, an instance of str, or a list of str, "
                    f"but got {type(name)}")

        # Direct registration: register_module(module=SomeClass)
        if module is not None:
            cls._register_module(module=module, module_name=name, force=force)
            return module

        # Decorator usage: @register_module()
        def _register(module):
            cls._register_module(module=module, module_name=name, force=force)
            return module

        return _register

    @classmethod
    def import_tool_call_parser(cls, plugin_path: str) -> None:
        """
        Import a user-defined tool parser from a file path.

        The file should contain a ToolParser subclass decorated with
        @ToolParserManager.register_module()

        Args:
            plugin_path: Path to the Python file containing the parser
        """
        if not os.path.exists(plugin_path):
            logger.error(f"Tool parser file not found: {plugin_path}")
            return

        module_name = os.path.splitext(os.path.basename(plugin_path))[0]

        try:
            # Import the module dynamically
            import importlib.util
            spec = importlib.util.spec_from_file_location(
                module_name, plugin_path)
            if spec is None or spec.loader is None:
                raise ImportError(f"Cannot load module from {plugin_path}")

            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
            logger.info(f"Successfully imported tool parser from {plugin_path}")
        except Exception:
            logger.exception(
                "Failed to load tool parser module '%s' from %s.",
                module_name,
                plugin_path,
            )
